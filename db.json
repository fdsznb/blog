{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"340499890fcdfc2fcb03e125ef0962f7462fe87c","modified":1675649851469},{"_id":"source/_posts/未完成的事情.md","hash":"f643cd9405db26dc7359600f79803f01bac7286e","modified":1676536443441},{"_id":"source/_posts/理论知识/设计模式/设计模式学习方法.md","hash":"6da4e7f9f1fd3b960584506cb4af68b565668dcb","modified":1676534675994},{"_id":"source/_posts/Java基础知识/多线程/学习过程中陌生的单词/学习过程中陌生的单词.md","hash":"b51ca3ead50a40f802238016659ad252f670ed0c","modified":1676535263597},{"_id":"source/_posts/Java基础知识/多线程/多线程学习篇/并发编程线程基础.md","hash":"95cc7ed6cd6c5985ebd33645a0124fc827f0efcb","modified":1676534498973},{"_id":"source/_posts/理论知识/设计模式/行为型模式/设计模式.md","hash":"e0b4bef2994eb754031fa8f6a4dc4c6357652433","modified":1676534644240},{"_id":"source/_posts/理论知识/设计模式/设计原则/设计原则.md","hash":"74cb13b17680377313ae99de021eacb192c78760","modified":1676534658511},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1675649851484},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1675649851484},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1675649851470},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1675649851470},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1675649851470},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1675649851471},{"_id":"themes/fluid/package.json","hash":"40e3a3fea5dedbc09e859a2ea6ce271004a57e87","modified":1675649851477},{"_id":"themes/fluid/languages/de.yml","hash":"288f649c2c2314eb610693b18853ee74f0541e87","modified":1675649851472},{"_id":"themes/fluid/LICENSE","hash":"694fb3659a4331dd752bd92e4248623bff8617cd","modified":1675649851471},{"_id":"themes/fluid/languages/en.yml","hash":"31f2867619a768606166778d4ee51f3d00ac33a0","modified":1675649851472},{"_id":"themes/fluid/languages/eo.yml","hash":"2c1c481d9af116e79fe55a0aa0bdbb143a97f559","modified":1675649851472},{"_id":"themes/fluid/languages/ja.yml","hash":"dc43be11a300893ebef47283c22f2f946ca21260","modified":1675649851472},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"3b92f4428d66c31610f6cde13b82ee723aff00d2","modified":1675649851472},{"_id":"themes/fluid/_config.yml","hash":"3452f1b187ac26fef819f9bab071c83bf8efe676","modified":1675656991042},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"de9b7e729d72eee9327671c3d5df0a607c4c3257","modified":1675649851472},{"_id":"themes/fluid/layout/404.ejs","hash":"79a598e43c40d48b23076361720f1e77df466e41","modified":1675649851472},{"_id":"themes/fluid/layout/archive.ejs","hash":"7a1e19dec37804927f0d331d7e6c80ed03becd61","modified":1675649851476},{"_id":"themes/fluid/layout/about.ejs","hash":"5b6de01c82b14834ab1e67f0a803612f5855f064","modified":1675649851476},{"_id":"themes/fluid/layout/category.ejs","hash":"dd2bd15cbd811d6ea973b6e6a17d99e36151e274","modified":1675649851477},{"_id":"themes/fluid/layout/categories.ejs","hash":"e7733779366ff6402615d96d4195f1196fa8351d","modified":1675649851477},{"_id":"themes/fluid/layout/index.ejs","hash":"bd118b6f7bd882a2ff896a1c4bc7bfa1c7694568","modified":1675649851477},{"_id":"themes/fluid/layout/layout.ejs","hash":"a1cea9b8fe0954d5a8d89941404f31ac344a4f5b","modified":1675649851477},{"_id":"themes/fluid/layout/tag.ejs","hash":"3a9296eb7181e8b3fb0cdc60cbafc815b98d6f51","modified":1675649851477},{"_id":"themes/fluid/layout/links.ejs","hash":"76807f949aaa20983b89efc9e6bc39108d022ac3","modified":1675649851477},{"_id":"themes/fluid/layout/post.ejs","hash":"edfeb655895027d15334d009324d27a29926cc94","modified":1675649851477},{"_id":"themes/fluid/layout/page.ejs","hash":"f867e69e563b8ad83054714f73d9173ea050d93b","modified":1675649851477},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"beb3474d6f65c1e56700ba872c6a0d0836d4168e","modified":1675649851471},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1675649851477},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"78ce211415d502c5a4398d786d5c697d34d868b9","modified":1675649851471},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1675649851471},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1675649851471},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"18381d03518526d7cefd024a0bdd8d9e7c6440f5","modified":1675649851471},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1675649851471},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1675649851471},{"_id":"themes/fluid/layout/_partial/archive-list.ejs","hash":"780117f8032df3b52169a387658a13cc025a0e13","modified":1675649851473},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"9af7ff960a421933169162ea1a2cd7e7577b0ed7","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"904971bf3419bec46de416c27dceb39a73063f33","modified":1675649851473},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"a137110fe5c4c13eb189dc53fe270c0d390a97e0","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"b7d5b438e2eeb624aecd86f3b321466834deac11","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"2af4653ed3fefdbcb12c16a6d2fa166d14672845","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1675649851475},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"00cdbf4c5e25a7f0c461ef460ae1af28c29e4712","modified":1675649851475},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"010b8b5ff2d1ae178cfba83a6c95d6345b053617","modified":1675649851475},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"bea21f1b5de61badd6c068080315c201fc80bc36","modified":1675649851476},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"a70c26e415a27f07f38b9384e7eb48d1f2b30328","modified":1675649851476},{"_id":"themes/fluid/scripts/events/index.js","hash":"91defe82d50a317903411f0b260da0f140f43dc4","modified":1675649851478},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"76e6bc368cf46d4103ea9514699e10ec0b9a4b56","modified":1675649851476},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1675649851479},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"cb72e5acfba882a6eacd6cae8db3238bb078737a","modified":1675649851479},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"bda7fbe58082a2a02c0db066794b791b14462271","modified":1675649851479},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"a2a15ea722863aba09dcad578558432682a3b6b3","modified":1675649851479},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"a26549407de10b994d1f6e37ba8fecf9dd4622de","modified":1675649851479},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1675649851479},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1675649851479},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"b6ccfffdee010ebd60cd8cc2386c43db076b6ca1","modified":1675649851479},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"9c01393f446c490c56b6b0d482aaa8d97cc8b717","modified":1675649851479},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1675649851480},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"dac0e08eaa3614a6fd9ddbdfb4584094b1bdb30a","modified":1675649851480},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1675649851480},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1675649851480},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1675649851480},{"_id":"themes/fluid/scripts/tags/note.js","hash":"8020acc2c4bb3a2054e3cb349fac7cd10b79a0be","modified":1675649851480},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1675649851480},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1675649851480},{"_id":"themes/fluid/scripts/utils/object.js","hash":"d798779ec79a53ce04b8ac79efd5d064981d95bd","modified":1675649851480},{"_id":"themes/fluid/source/css/main.styl","hash":"bf536db598434c36cc0c752196bfde46e584a92e","modified":1675649851485},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1675649851485},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1675649851485},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1675649851488},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1675649851488},{"_id":"themes/fluid/source/js/boot.js","hash":"5264c0d2eb73b4948ee6bcb1bd847a924d906088","modified":1675649851488},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1675649851489},{"_id":"themes/fluid/source/js/events.js","hash":"b019f58951cc02c5fd1863e2e05101254bf2896c","modified":1675649851489},{"_id":"themes/fluid/source/js/leancloud.js","hash":"9115c754794bfd20e84b61f3beb1ec37773b4c0c","modified":1675649851489},{"_id":"themes/fluid/source/js/color-schema.js","hash":"719296a8b6e1b76ec682554fb3dbcc75a2a2d78d","modified":1675649851489},{"_id":"themes/fluid/source/js/local-search.js","hash":"90d7eb35aff2994fa173abeed7ce0c91357f5979","modified":1675649851489},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1675649851490},{"_id":"themes/fluid/source/js/plugins.js","hash":"75b1d3e58fdfc5230608a0f7d116e41c93050cef","modified":1675649851490},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1675649851473},{"_id":"themes/fluid/source/js/utils.js","hash":"a2da89bb185fcd9de7a834e862b03548f5efcd04","modified":1675649851490},{"_id":"themes/fluid/layout/_partial/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1675649851473},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1675649851473},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1675649851473},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1675649851473},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1675649851473},{"_id":"themes/fluid/layout/_partial/comments/twikoo.ejs","hash":"93d47bc528bf1a3d0fe950fc21a2da787e1b7dc9","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"d1e86754c9560f7346200b2aa9a7f715a3fac82b","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"bd2b8843094966dbc96c3768b4858c6e241a59a9","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/comments/waline.ejs","hash":"d81bfb2f594d597f0e176abc09a76f3f58b98c2e","modified":1675649851474},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"fd1f78287c868ccab78b6244b66e3f9b0968c4a8","modified":1675649851475},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"d20f54bf2fd5cd274b4b9c5542eafbfec5120838","modified":1675649851475},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"80cdaa9da8770568af5bb06a66829dddf1d683d2","modified":1675649851475},{"_id":"themes/fluid/layout/_partial/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1675649851475},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"c0da20f9adca2761d370cc6dda013ec1ecbb7710","modified":1675649851478},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"13d8466cd4c98367131b5f3d6a30b3d4ce8de26f","modified":1675649851478},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"842da2fc1c99a3fb887b5e36b76625c9a1b3401a","modified":1675649851475},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"b4148d2283431a2edd5d04bbfcebd76941254476","modified":1675649851478},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"af80de29f06b4f64c31fe070a2af292876717ee1","modified":1675649851478},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1675649851478},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"3f2dba4959b27466521de97eff692815650c02b7","modified":1675649851478},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1675649851481},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1675649851485},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1675649851481},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1675649851481},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"86926a80bf6f39a7f47789b1a8f44b5984b4683f","modified":1675649851481},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"35179cd560f9919376abdcf99e0d23f20e18e84f","modified":1675649851485},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"0d6d39709999c8e1786ed64c6f5bbdc4acd21813","modified":1675649851483},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1675649851483},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"ed0f3aae95edac702ed497f6e8a76b33f39f8c89","modified":1675649851483},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"6f2a3b8af2793dd831f661c6db0ccbe0a62ccc48","modified":1675649851483},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"67103d8eb96cd94d185c00011b809eecdb88823a","modified":1675649851483},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"0924e35eff2ec84e2d9e4772abccda452d9463ef","modified":1675649851484},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"cd81947721c5aecc1cc8d4658599837701ef8af3","modified":1675649851484},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"2eaac14a1af09cf6a1ab24201e182ac2aca40385","modified":1675649851484},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"10fcf4291b6efd5036214b7dde57ed2e3878fc1a","modified":1675649851484},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"4123f77c742d94e903f7196350c830cbccf8669a","modified":1675649851484},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1675649851485},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"bb9cdde191b9b1287ba19414bab862f30be6a8a0","modified":1675649851482},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"f770c5c3ee89421e9e3f1313ca5bd07a2448f400","modified":1675649851482},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"c398892fba1494dd6fd417415076458ed321d34d","modified":1675649851482},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1675649851482},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"da823846f0896f16b21c7430f047f7222a89cd10","modified":1675649851481},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e77f5c5d5da17a7e6241cca0e1d4e8cd07169c64","modified":1675649851482},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1675649851483},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1675649851483},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e568f308df26465e0432197e8b57384707470f54","modified":1675649851483},{"_id":"themes/fluid/source/img/default.png","hash":"1eec8e152fbfcc661dc7eeb354498e6b2b88f64e","modified":1675649851487},{"_id":"themes/fluid/source/img/favicon.png","hash":"2aa1743dc823866820bdcd1bfca35efa235dd6ad","modified":1675649851488},{"_id":"public/local-search.xml","hash":"4c0795f9aed096fe0763e5901fbc3a409ea339a2","modified":1676536451781},{"_id":"public/2099/02/16/未完成的事情/index.html","hash":"c355fd2c0fd55d885df1fa0cfad1de16c4837c18","modified":1676536451781},{"_id":"public/2023/02/14/理论知识/设计模式/设计原则/设计原则/index.html","hash":"d367a1ea6a838439ef7d9ee767dab6008b9dfa2e","modified":1676536451781},{"_id":"public/2023/02/14/Java基础知识/多线程/学习过程中陌生的单词/学习过程中陌生的单词/index.html","hash":"3a8d70ee731e02844e963c6a9e0b3052a449860d","modified":1676536451781},{"_id":"public/2023/02/14/理论知识/设计模式/行为型模式/设计模式/index.html","hash":"017058f8c0d8e59c509356e2e527fd9f6b8769fa","modified":1676536451781},{"_id":"public/2023/02/14/理论知识/设计模式/设计模式学习方法/index.html","hash":"50b1ad7cdb899c6ea0acc38bde7163ea5983ba50","modified":1676536451781},{"_id":"public/categories/理论知识/index.html","hash":"2de31b77779537e66c457f7facf498f1bb9eb8d9","modified":1676536451781},{"_id":"public/categories/Java基础知识/index.html","hash":"8fbe55e6c2602452d1ee9f328da974e7db9ad478","modified":1676536451781},{"_id":"public/categories/单词学习/index.html","hash":"c3967bc2bb6d4214d95c01abba009fecfe968aba","modified":1676536451781},{"_id":"public/categories/理论知识/设计模式/index.html","hash":"8dd86d0e87109e2c469eac38e692d78b3050cc5f","modified":1676536451781},{"_id":"public/categories/Java基础知识/多线程学习/index.html","hash":"4034fcb9d87d2c026a8796c02e4968e67a786ae3","modified":1676536451781},{"_id":"public/categories/理论知识/设计模式/行为型模式/index.html","hash":"438d27ff995ea70b7195fd2137fc53475395d998","modified":1676536451781},{"_id":"public/categories/理论知识/设计模式/设计原则/index.html","hash":"cd1af109bb95e4e775607b090b17f852ab61890c","modified":1676536451781},{"_id":"public/archives/index.html","hash":"eee610dfc84083dc430362f8c411d858a8f7a6bf","modified":1676536451781},{"_id":"public/archives/2023/index.html","hash":"83833f4be674b8632288bce8732d89580060b278","modified":1676536451781},{"_id":"public/archives/2023/02/index.html","hash":"1ead09f8c8640745df5c04d31c3d2628d84fb724","modified":1676536451781},{"_id":"public/archives/2099/index.html","hash":"b58d799627766bb6766a2d525f04e1d1b90cab4c","modified":1676536451781},{"_id":"public/archives/2099/02/index.html","hash":"9f7263e0318b05dd2ad5f3036cfb77008567dfdb","modified":1676536451781},{"_id":"public/tags/设计模式/index.html","hash":"67c4cac75350a77fa120a1e9d238d88ece5e646e","modified":1676536451781},{"_id":"public/tags/单词学习/index.html","hash":"b39645fe10267b618df18fdc604a9aae9d050799","modified":1676536451781},{"_id":"public/tags/设计原则/index.html","hash":"7cf1e64738c8ea0a604ed19eff3f43042e4f6c51","modified":1676536451781},{"_id":"public/404.html","hash":"d6c6677013b5210d149befc0cc17cfbb5313e264","modified":1676536451781},{"_id":"public/tags/index.html","hash":"22f35fedb05c3eba6a1528bb6a38a44e4a891982","modified":1676536451781},{"_id":"public/categories/index.html","hash":"545f79a58892f248ba03b6be12523cdb00067723","modified":1676536451781},{"_id":"public/links/index.html","hash":"6e5c47d3d7949023aa1b8e9fd9e34325551b7fc1","modified":1676536451781},{"_id":"public/2023/02/15/Java基础知识/多线程/多线程学习篇/并发编程线程基础/index.html","hash":"ebb931a72a0112df46e4ce2f9d373e10758466c8","modified":1676536451781},{"_id":"public/index.html","hash":"ac20589843a3286e3ea1a6d9fd532c11a61187f9","modified":1676536451781},{"_id":"public/CNAME","hash":"340499890fcdfc2fcb03e125ef0962f7462fe87c","modified":1676536451781},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1676536451781},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1676536451781},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1676536451781},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1676536451781},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1676536451781},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1676536451781},{"_id":"public/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1676536451781},{"_id":"public/js/events.js","hash":"41632930eca3e763cc1cf2de0b521e602dc72152","modified":1676536451781},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1676536451781},{"_id":"public/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1676536451781},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1676536451781},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1676536451781},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1676536451781},{"_id":"public/css/main.css","hash":"9487432febfab1b5440bfb31c1d0bcdd07268710","modified":1676536451781},{"_id":"public/img/default.png","hash":"1eec8e152fbfcc661dc7eeb354498e6b2b88f64e","modified":1676536451781},{"_id":"public/img/favicon.png","hash":"2aa1743dc823866820bdcd1bfca35efa235dd6ad","modified":1676536451781}],"Category":[{"name":"理论知识","_id":"cle6uilnh0003rgtv2qpm55ol"},{"name":"Java基础知识","_id":"cle6uilnt0008rgtvcpfm0ub3"},{"name":"单词学习","_id":"cle6uilnv000crgtv3ob143se"},{"name":"设计模式","parent":"cle6uilnh0003rgtv2qpm55ol","_id":"cle6uilnw000frgtvfsw46sjl"},{"name":"多线程学习","parent":"cle6uilnt0008rgtvcpfm0ub3","_id":"cle6uilny000krgtv8kd7b90q"},{"name":"行为型模式","parent":"cle6uilnw000frgtvfsw46sjl","_id":"cle6uilnz000nrgtvc7yc6raq"},{"name":"设计原则","parent":"cle6uilnw000frgtvfsw46sjl","_id":"cle6uilo0000prgtv1mzqa9em"}],"Data":[],"Page":[],"Post":[{"title":"未完成的事情","date":"2099-02-16T08:33:23.000Z","description":null,"_content":"\n* 设计模式\n* ThreadLocal 源码解析理解","source":"_posts/未完成的事情.md","raw":"---\ntitle: 未完成的事情\ncategories: []\ndate: 2099-02-16 16:33:23\ntags:\ndescription:\n---\n\n* 设计模式\n* ThreadLocal 源码解析理解","slug":"未完成的事情","published":1,"updated":"2023-02-16T08:34:03.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle6uiln60000rgtv1108c01r","content":"<ul>\n<li>设计模式</li>\n<li>ThreadLocal 源码解析理解</li>\n</ul>\n","site":{"data":{}},"wordcount":21,"excerpt":"","more":"<ul>\n<li>设计模式</li>\n<li>ThreadLocal 源码解析理解</li>\n</ul>\n"},{"title":"设计模式学习方法","date":"2023-02-14T03:00:00.000Z","description":"设计模式学习方法","_content":"\n## 让大脑就范的方法\n\n* 慢一点，你理解的越多，记得就越少\n* 勤做练习，自己做笔记\n* 阅读 \"There are no Dumb Questions\" 部分\n* 上床睡觉前不要再看别的书本了，或至少不再看其它有难度的东西\n* 要喝水，而且要多喝水\n* 大声说出来\n* 听听你的大脑怎么说\n* 要有点感觉\n* 设计一些东西\n\n参考《HEAD FIRST设计模式 （中文版）》","source":"_posts/理论知识/设计模式/设计模式学习方法.md","raw":"---\ntitle: 设计模式学习方法\ncategories: [\"理论知识\", \"设计模式\"]\ndate: 2023-02-14 11:00:00\ntags: 设计模式\ndescription: 设计模式学习方法\n---\n\n## 让大脑就范的方法\n\n* 慢一点，你理解的越多，记得就越少\n* 勤做练习，自己做笔记\n* 阅读 \"There are no Dumb Questions\" 部分\n* 上床睡觉前不要再看别的书本了，或至少不再看其它有难度的东西\n* 要喝水，而且要多喝水\n* 大声说出来\n* 听听你的大脑怎么说\n* 要有点感觉\n* 设计一些东西\n\n参考《HEAD FIRST设计模式 （中文版）》","slug":"理论知识/设计模式/设计模式学习方法","published":1,"updated":"2023-02-16T08:04:35.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle6uilnb0001rgtv114k32d6","content":"<h2 id=\"让大脑就范的方法\"><a href=\"#让大脑就范的方法\" class=\"headerlink\" title=\"让大脑就范的方法\"></a>让大脑就范的方法</h2><ul>\n<li>慢一点，你理解的越多，记得就越少</li>\n<li>勤做练习，自己做笔记</li>\n<li>阅读 “There are no Dumb Questions” 部分</li>\n<li>上床睡觉前不要再看别的书本了，或至少不再看其它有难度的东西</li>\n<li>要喝水，而且要多喝水</li>\n<li>大声说出来</li>\n<li>听听你的大脑怎么说</li>\n<li>要有点感觉</li>\n<li>设计一些东西</li>\n</ul>\n<p>参考《HEAD FIRST设计模式 （中文版）》</p>\n","site":{"data":{}},"wordcount":149,"excerpt":"","more":"<h2 id=\"让大脑就范的方法\"><a href=\"#让大脑就范的方法\" class=\"headerlink\" title=\"让大脑就范的方法\"></a>让大脑就范的方法</h2><ul>\n<li>慢一点，你理解的越多，记得就越少</li>\n<li>勤做练习，自己做笔记</li>\n<li>阅读 “There are no Dumb Questions” 部分</li>\n<li>上床睡觉前不要再看别的书本了，或至少不再看其它有难度的东西</li>\n<li>要喝水，而且要多喝水</li>\n<li>大声说出来</li>\n<li>听听你的大脑怎么说</li>\n<li>要有点感觉</li>\n<li>设计一些东西</li>\n</ul>\n<p>参考《HEAD FIRST设计模式 （中文版）》</p>\n"},{"title":"并发编程线程基础","date":"2023-02-15T01:15:54.000Z","description":null,"_content":"## 一、并发编程线程基础\n### 1.什么是进程、线程\n进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程至少有一个线程，进程中的多个线程共享进程的资源。\n>操作系统在分配资源时是把资源分配给进程的，但是 CPU 资源比较特殊，它是分配到线程的，因为真正要占用 CPU 运行的是线程，所以也说线程是 CPU 分配的基本单位。\n\n### 2.线程创建的三种方式\nJava 中有线程创建方式，分别为实现 Runnable 接口的 run 方法，继承 Thread 类并重写 run 方法，使用 FutureTask 方式。\n\n#### 2.1 继承 Thread 类并重写 run 方法\n```java\npublic class ExtendThreadDemo {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        /**\n         * 其实调用 start 方法后线程并没有马上执行而 处于就 状态， 这个就绪状态是指\n         * 线程已经获取了除 CPU 资源外的其 资源，等待获取 CPU 资源后才会真正处于运行状态。\n         * 一旦 run 方法执行完毕， 该线程就处于终止状态\n         */\n        myThread.start();\n    }\n\n    public static class MyThread extends Thread{\n        @Override\n        public void run() {\n            System.out.println(\"This a thread's run method.\");\n        }\n    }\n}\n```\n\n\n#### 2.2 实现 Runnable 的 run 方法\n```java\npublic class ImplementRunnableThreadDemo {\n    public static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(\"I'm a thread run method.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        new Thread(myThread).start();\n        new Thread(myThread).start();\n    }\n}\n```\n\n#### 2.3 使用 FutureTask 方式\n```java\npublic class FutureTaskThreadDemo {\n\n    public static class CallerTask implements Callable<String> {\n\n        @Override\n        public String call() throws Exception {\n            return \"violet\";\n        }\n    }\n\n    public static void main(String[] args) {\n        FutureTask<String> futureTask = new FutureTask<String>(new CallerTask()); \n        new Thread(futureTask).start();\n        \n        try {\n            String res = futureTask.get();\n            System.out.println(\"线程执行完成返回结果：\" + res);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 3.线程通知与等待\nJava 中的 Object 类是所有类的父类，鉴于继承机制， Java 把所有类都需要的方法放到了 Object 类里面，其中就包含线程通知与等待系列函数。\n\n#### 3.1 wait() 函数\n当一个线程调用一个共享变量 wait() 方法时, 该调用线程会被阻塞挂起, 到发生下面几件事情之一才返回:\n* 其他线程调用了该共享对象 notify() 或者 notifyAll() 方法\n* 其他线程调用了该线程 interrupt() 方法, 该线程抛出 InterruptedException 异常返回。\n\n>如果调用 wait()方法的线程没有事先获取该对象的监视器锁，则调用 wait() 方法时调用 线程会抛出 IllegalMonitorStateExce ption 异常。\n\n#### 3.2 notify() 函数\n唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程。\n\n#### 3.3 notifyAll() 函数\n唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。\n\n#### 3.4等待线程执行终止的 join 方法\n在项目实践中经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。\n\n#### 3.5 让线程睡眠的 sleep 方法\n当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。\n\n#### 3.6 让出 CPU 执行权的 yield 方法\nThread 有一个静态的 yield 方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己 CPU 使用，但是线程调度器可以无条件忽略这个暗示。\n\n#### 3.7 线程中断\nJava 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。\n\n* **void interrupt()**: 中断线程，例如，当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。设置标志仅仅是设置标志，线程 A 实际并没有被中断，它会继续往下执行。如果线程 A 因为调用了 wait 系列函数、join 方法或者 sleep 方法而被阻塞挂起，这时候若线程 B 调用线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。\n* **boolean isInterrupted() 方法**: 检测当前线程是否被中断，如果是返回 true, 否则返回 false。  \n* **boolean interrupted() 方法**: 检测当前线程是否被中断，如果是返回 true，否则返回 false。与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是 static 方法，可以通过 Thread 类直接调用。另外从下面给的代码可以知道，在 interrupted() 内部是获取当前调用线程的中断标志而不是调用 interrupted() 方法的实例对象的中断标志。\n\n#### 3.8 理解线程上下文切换\n当前线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占有，这就是上下文切换。\n>线程上下文切换时机有：当前线程的 CPU 时间片使用完处于就绪状态时，当前线程被其他线程中断时。\n\n#### 3.9 线程死锁\n##### 3.9.1 什么是线程死锁\n死锁是指两个或两个以上的线程在执行任务过程中，因争夺资源而造成的互相等待的现象。\n\n##### 3.9.2 死锁产生的必要条件\n* 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。\n\n* 请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所有当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。\n\n* 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。\n\n* 环路等待条件：指在发生死锁时，必然存在一个线程--资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源，T1 正在等待 T2 占用的资源，······Tn 正在等待已被 T0 占用的资源。\n\n##### 3.9.3 如何避免线程死锁\n要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但是学过操作系统的读者应该都知道，目前只有请求并持有和环路等待条件是可以被破坏的。\n\n#### 3.10 守护线程与用户线程\n守护线程是为用户线程服务的，当一个程序中的所有用户线程都执行完成之后程序就会结束运行，程序结束运行时不会管守护线程是否正在运行。\n>即使是守护线程，当程序中调用 join() 方法时，程序依然会等待守护线程执行完成之后再结束进程。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 参考\n* 《Java并发编程之美》","source":"_posts/Java基础知识/多线程/多线程学习篇/并发编程线程基础.md","raw":"---\ntitle: 并发编程线程基础\ncategories: [\"Java基础知识\", \"多线程学习\"]\ndate: 2023-02-15 09:15:54\ntags:\ndescription:\n---\n## 一、并发编程线程基础\n### 1.什么是进程、线程\n进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程至少有一个线程，进程中的多个线程共享进程的资源。\n>操作系统在分配资源时是把资源分配给进程的，但是 CPU 资源比较特殊，它是分配到线程的，因为真正要占用 CPU 运行的是线程，所以也说线程是 CPU 分配的基本单位。\n\n### 2.线程创建的三种方式\nJava 中有线程创建方式，分别为实现 Runnable 接口的 run 方法，继承 Thread 类并重写 run 方法，使用 FutureTask 方式。\n\n#### 2.1 继承 Thread 类并重写 run 方法\n```java\npublic class ExtendThreadDemo {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        /**\n         * 其实调用 start 方法后线程并没有马上执行而 处于就 状态， 这个就绪状态是指\n         * 线程已经获取了除 CPU 资源外的其 资源，等待获取 CPU 资源后才会真正处于运行状态。\n         * 一旦 run 方法执行完毕， 该线程就处于终止状态\n         */\n        myThread.start();\n    }\n\n    public static class MyThread extends Thread{\n        @Override\n        public void run() {\n            System.out.println(\"This a thread's run method.\");\n        }\n    }\n}\n```\n\n\n#### 2.2 实现 Runnable 的 run 方法\n```java\npublic class ImplementRunnableThreadDemo {\n    public static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(\"I'm a thread run method.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        new Thread(myThread).start();\n        new Thread(myThread).start();\n    }\n}\n```\n\n#### 2.3 使用 FutureTask 方式\n```java\npublic class FutureTaskThreadDemo {\n\n    public static class CallerTask implements Callable<String> {\n\n        @Override\n        public String call() throws Exception {\n            return \"violet\";\n        }\n    }\n\n    public static void main(String[] args) {\n        FutureTask<String> futureTask = new FutureTask<String>(new CallerTask()); \n        new Thread(futureTask).start();\n        \n        try {\n            String res = futureTask.get();\n            System.out.println(\"线程执行完成返回结果：\" + res);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 3.线程通知与等待\nJava 中的 Object 类是所有类的父类，鉴于继承机制， Java 把所有类都需要的方法放到了 Object 类里面，其中就包含线程通知与等待系列函数。\n\n#### 3.1 wait() 函数\n当一个线程调用一个共享变量 wait() 方法时, 该调用线程会被阻塞挂起, 到发生下面几件事情之一才返回:\n* 其他线程调用了该共享对象 notify() 或者 notifyAll() 方法\n* 其他线程调用了该线程 interrupt() 方法, 该线程抛出 InterruptedException 异常返回。\n\n>如果调用 wait()方法的线程没有事先获取该对象的监视器锁，则调用 wait() 方法时调用 线程会抛出 IllegalMonitorStateExce ption 异常。\n\n#### 3.2 notify() 函数\n唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程。\n\n#### 3.3 notifyAll() 函数\n唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。\n\n#### 3.4等待线程执行终止的 join 方法\n在项目实践中经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。\n\n#### 3.5 让线程睡眠的 sleep 方法\n当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。\n\n#### 3.6 让出 CPU 执行权的 yield 方法\nThread 有一个静态的 yield 方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己 CPU 使用，但是线程调度器可以无条件忽略这个暗示。\n\n#### 3.7 线程中断\nJava 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。\n\n* **void interrupt()**: 中断线程，例如，当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。设置标志仅仅是设置标志，线程 A 实际并没有被中断，它会继续往下执行。如果线程 A 因为调用了 wait 系列函数、join 方法或者 sleep 方法而被阻塞挂起，这时候若线程 B 调用线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。\n* **boolean isInterrupted() 方法**: 检测当前线程是否被中断，如果是返回 true, 否则返回 false。  \n* **boolean interrupted() 方法**: 检测当前线程是否被中断，如果是返回 true，否则返回 false。与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是 static 方法，可以通过 Thread 类直接调用。另外从下面给的代码可以知道，在 interrupted() 内部是获取当前调用线程的中断标志而不是调用 interrupted() 方法的实例对象的中断标志。\n\n#### 3.8 理解线程上下文切换\n当前线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占有，这就是上下文切换。\n>线程上下文切换时机有：当前线程的 CPU 时间片使用完处于就绪状态时，当前线程被其他线程中断时。\n\n#### 3.9 线程死锁\n##### 3.9.1 什么是线程死锁\n死锁是指两个或两个以上的线程在执行任务过程中，因争夺资源而造成的互相等待的现象。\n\n##### 3.9.2 死锁产生的必要条件\n* 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。\n\n* 请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所有当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。\n\n* 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。\n\n* 环路等待条件：指在发生死锁时，必然存在一个线程--资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源，T1 正在等待 T2 占用的资源，······Tn 正在等待已被 T0 占用的资源。\n\n##### 3.9.3 如何避免线程死锁\n要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但是学过操作系统的读者应该都知道，目前只有请求并持有和环路等待条件是可以被破坏的。\n\n#### 3.10 守护线程与用户线程\n守护线程是为用户线程服务的，当一个程序中的所有用户线程都执行完成之后程序就会结束运行，程序结束运行时不会管守护线程是否正在运行。\n>即使是守护线程，当程序中调用 join() 方法时，程序依然会等待守护线程执行完成之后再结束进程。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 参考\n* 《Java并发编程之美》","slug":"Java基础知识/多线程/多线程学习篇/并发编程线程基础","published":1,"updated":"2023-02-16T08:01:38.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle6uilne0002rgtvh5ssb5k1","content":"<h2 id=\"一、并发编程线程基础\"><a href=\"#一、并发编程线程基础\" class=\"headerlink\" title=\"一、并发编程线程基础\"></a>一、并发编程线程基础</h2><h3 id=\"1-什么是进程、线程\"><a href=\"#1-什么是进程、线程\" class=\"headerlink\" title=\"1.什么是进程、线程\"></a>1.什么是进程、线程</h3><p>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程至少有一个线程，进程中的多个线程共享进程的资源。</p>\n<blockquote>\n<p>操作系统在分配资源时是把资源分配给进程的，但是 CPU 资源比较特殊，它是分配到线程的，因为真正要占用 CPU 运行的是线程，所以也说线程是 CPU 分配的基本单位。</p>\n</blockquote>\n<h3 id=\"2-线程创建的三种方式\"><a href=\"#2-线程创建的三种方式\" class=\"headerlink\" title=\"2.线程创建的三种方式\"></a>2.线程创建的三种方式</h3><p>Java 中有线程创建方式，分别为实现 Runnable 接口的 run 方法，继承 Thread 类并重写 run 方法，使用 FutureTask 方式。</p>\n<h4 id=\"2-1-继承-Thread-类并重写-run-方法\"><a href=\"#2-1-继承-Thread-类并重写-run-方法\" class=\"headerlink\" title=\"2.1 继承 Thread 类并重写 run 方法\"></a>2.1 继承 Thread 类并重写 run 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExtendThreadDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">MyThread</span> <span class=\"hljs-variable\">myThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyThread</span>();<br>        <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 其实调用 start 方法后线程并没有马上执行而 处于就 状态， 这个就绪状态是指</span><br><span class=\"hljs-comment\">         * 线程已经获取了除 CPU 资源外的其 资源，等待获取 CPU 资源后才会真正处于运行状态。</span><br><span class=\"hljs-comment\">         * 一旦 run 方法执行完毕， 该线程就处于终止状态</span><br><span class=\"hljs-comment\">         */</span><br>        myThread.start();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Thread</span>&#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;This a thread&#x27;s run method.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n<h4 id=\"2-2-实现-Runnable-的-run-方法\"><a href=\"#2-2-实现-Runnable-的-run-方法\" class=\"headerlink\" title=\"2.2 实现 Runnable 的 run 方法\"></a>2.2 实现 Runnable 的 run 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImplementRunnableThreadDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyThread</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;I&#x27;m a thread run method.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">MyThread</span> <span class=\"hljs-variable\">myThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyThread</span>();<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(myThread).start();<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(myThread).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-使用-FutureTask-方式\"><a href=\"#2-3-使用-FutureTask-方式\" class=\"headerlink\" title=\"2.3 使用 FutureTask 方式\"></a>2.3 使用 FutureTask 方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FutureTaskThreadDemo</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CallerTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Callable</span>&lt;String&gt; &#123;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;violet&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FutureTask</span>&lt;String&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CallerTask</span>()); <br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(futureTask).start();<br>        <br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">res</span> <span class=\"hljs-operator\">=</span> futureTask.get();<br>            System.out.println(<span class=\"hljs-string\">&quot;线程执行完成返回结果：&quot;</span> + res);<br>        &#125; <span class=\"hljs-keyword\">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<h3 id=\"3-线程通知与等待\"><a href=\"#3-线程通知与等待\" class=\"headerlink\" title=\"3.线程通知与等待\"></a>3.线程通知与等待</h3><p>Java 中的 Object 类是所有类的父类，鉴于继承机制， Java 把所有类都需要的方法放到了 Object 类里面，其中就包含线程通知与等待系列函数。</p>\n<h4 id=\"3-1-wait-函数\"><a href=\"#3-1-wait-函数\" class=\"headerlink\" title=\"3.1 wait() 函数\"></a>3.1 wait() 函数</h4><p>当一个线程调用一个共享变量 wait() 方法时, 该调用线程会被阻塞挂起, 到发生下面几件事情之一才返回:</p>\n<ul>\n<li>其他线程调用了该共享对象 notify() 或者 notifyAll() 方法</li>\n<li>其他线程调用了该线程 interrupt() 方法, 该线程抛出 InterruptedException 异常返回。</li>\n</ul>\n<blockquote>\n<p>如果调用 wait()方法的线程没有事先获取该对象的监视器锁，则调用 wait() 方法时调用 线程会抛出 IllegalMonitorStateExce ption 异常。</p>\n</blockquote>\n<h4 id=\"3-2-notify-函数\"><a href=\"#3-2-notify-函数\" class=\"headerlink\" title=\"3.2 notify() 函数\"></a>3.2 notify() 函数</h4><p>唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程。</p>\n<h4 id=\"3-3-notifyAll-函数\"><a href=\"#3-3-notifyAll-函数\" class=\"headerlink\" title=\"3.3 notifyAll() 函数\"></a>3.3 notifyAll() 函数</h4><p>唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</p>\n<h4 id=\"3-4等待线程执行终止的-join-方法\"><a href=\"#3-4等待线程执行终止的-join-方法\" class=\"headerlink\" title=\"3.4等待线程执行终止的 join 方法\"></a>3.4等待线程执行终止的 join 方法</h4><p>在项目实践中经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。</p>\n<h4 id=\"3-5-让线程睡眠的-sleep-方法\"><a href=\"#3-5-让线程睡眠的-sleep-方法\" class=\"headerlink\" title=\"3.5 让线程睡眠的 sleep 方法\"></a>3.5 让线程睡眠的 sleep 方法</h4><p>当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。</p>\n<h4 id=\"3-6-让出-CPU-执行权的-yield-方法\"><a href=\"#3-6-让出-CPU-执行权的-yield-方法\" class=\"headerlink\" title=\"3.6 让出 CPU 执行权的 yield 方法\"></a>3.6 让出 CPU 执行权的 yield 方法</h4><p>Thread 有一个静态的 yield 方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己 CPU 使用，但是线程调度器可以无条件忽略这个暗示。</p>\n<h4 id=\"3-7-线程中断\"><a href=\"#3-7-线程中断\" class=\"headerlink\" title=\"3.7 线程中断\"></a>3.7 线程中断</h4><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p>\n<ul>\n<li><strong>void interrupt()</strong>: 中断线程，例如，当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。设置标志仅仅是设置标志，线程 A 实际并没有被中断，它会继续往下执行。如果线程 A 因为调用了 wait 系列函数、join 方法或者 sleep 方法而被阻塞挂起，这时候若线程 B 调用线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。</li>\n<li><strong>boolean isInterrupted() 方法</strong>: 检测当前线程是否被中断，如果是返回 true, 否则返回 false。  </li>\n<li><strong>boolean interrupted() 方法</strong>: 检测当前线程是否被中断，如果是返回 true，否则返回 false。与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是 static 方法，可以通过 Thread 类直接调用。另外从下面给的代码可以知道，在 interrupted() 内部是获取当前调用线程的中断标志而不是调用 interrupted() 方法的实例对象的中断标志。</li>\n</ul>\n<h4 id=\"3-8-理解线程上下文切换\"><a href=\"#3-8-理解线程上下文切换\" class=\"headerlink\" title=\"3.8 理解线程上下文切换\"></a>3.8 理解线程上下文切换</h4><p>当前线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占有，这就是上下文切换。</p>\n<blockquote>\n<p>线程上下文切换时机有：当前线程的 CPU 时间片使用完处于就绪状态时，当前线程被其他线程中断时。</p>\n</blockquote>\n<h4 id=\"3-9-线程死锁\"><a href=\"#3-9-线程死锁\" class=\"headerlink\" title=\"3.9 线程死锁\"></a>3.9 线程死锁</h4><h5 id=\"3-9-1-什么是线程死锁\"><a href=\"#3-9-1-什么是线程死锁\" class=\"headerlink\" title=\"3.9.1 什么是线程死锁\"></a>3.9.1 什么是线程死锁</h5><p>死锁是指两个或两个以上的线程在执行任务过程中，因争夺资源而造成的互相等待的现象。</p>\n<h5 id=\"3-9-2-死锁产生的必要条件\"><a href=\"#3-9-2-死锁产生的必要条件\" class=\"headerlink\" title=\"3.9.2 死锁产生的必要条件\"></a>3.9.2 死锁产生的必要条件</h5><ul>\n<li><p>互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</p>\n</li>\n<li><p>请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所有当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</p>\n</li>\n<li><p>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</p>\n</li>\n<li><p>环路等待条件：指在发生死锁时，必然存在一个线程–资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源，T1 正在等待 T2 占用的资源，······Tn 正在等待已被 T0 占用的资源。</p>\n</li>\n</ul>\n<h5 id=\"3-9-3-如何避免线程死锁\"><a href=\"#3-9-3-如何避免线程死锁\" class=\"headerlink\" title=\"3.9.3 如何避免线程死锁\"></a>3.9.3 如何避免线程死锁</h5><p>要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但是学过操作系统的读者应该都知道，目前只有请求并持有和环路等待条件是可以被破坏的。</p>\n<h4 id=\"3-10-守护线程与用户线程\"><a href=\"#3-10-守护线程与用户线程\" class=\"headerlink\" title=\"3.10 守护线程与用户线程\"></a>3.10 守护线程与用户线程</h4><p>守护线程是为用户线程服务的，当一个程序中的所有用户线程都执行完成之后程序就会结束运行，程序结束运行时不会管守护线程是否正在运行。</p>\n<blockquote>\n<p>即使是守护线程，当程序中调用 join() 方法时，程序依然会等待守护线程执行完成之后再结束进程。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>《Java并发编程之美》</li>\n</ul>\n","site":{"data":{}},"wordcount":3570,"excerpt":"","more":"<h2 id=\"一、并发编程线程基础\"><a href=\"#一、并发编程线程基础\" class=\"headerlink\" title=\"一、并发编程线程基础\"></a>一、并发编程线程基础</h2><h3 id=\"1-什么是进程、线程\"><a href=\"#1-什么是进程、线程\" class=\"headerlink\" title=\"1.什么是进程、线程\"></a>1.什么是进程、线程</h3><p>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程至少有一个线程，进程中的多个线程共享进程的资源。</p>\n<blockquote>\n<p>操作系统在分配资源时是把资源分配给进程的，但是 CPU 资源比较特殊，它是分配到线程的，因为真正要占用 CPU 运行的是线程，所以也说线程是 CPU 分配的基本单位。</p>\n</blockquote>\n<h3 id=\"2-线程创建的三种方式\"><a href=\"#2-线程创建的三种方式\" class=\"headerlink\" title=\"2.线程创建的三种方式\"></a>2.线程创建的三种方式</h3><p>Java 中有线程创建方式，分别为实现 Runnable 接口的 run 方法，继承 Thread 类并重写 run 方法，使用 FutureTask 方式。</p>\n<h4 id=\"2-1-继承-Thread-类并重写-run-方法\"><a href=\"#2-1-继承-Thread-类并重写-run-方法\" class=\"headerlink\" title=\"2.1 继承 Thread 类并重写 run 方法\"></a>2.1 继承 Thread 类并重写 run 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExtendThreadDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">MyThread</span> <span class=\"hljs-variable\">myThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyThread</span>();<br>        <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 其实调用 start 方法后线程并没有马上执行而 处于就 状态， 这个就绪状态是指</span><br><span class=\"hljs-comment\">         * 线程已经获取了除 CPU 资源外的其 资源，等待获取 CPU 资源后才会真正处于运行状态。</span><br><span class=\"hljs-comment\">         * 一旦 run 方法执行完毕， 该线程就处于终止状态</span><br><span class=\"hljs-comment\">         */</span><br>        myThread.start();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Thread</span>&#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;This a thread&#x27;s run method.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-2-实现-Runnable-的-run-方法\"><a href=\"#2-2-实现-Runnable-的-run-方法\" class=\"headerlink\" title=\"2.2 实现 Runnable 的 run 方法\"></a>2.2 实现 Runnable 的 run 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImplementRunnableThreadDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyThread</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;I&#x27;m a thread run method.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">MyThread</span> <span class=\"hljs-variable\">myThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyThread</span>();<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(myThread).start();<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(myThread).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-使用-FutureTask-方式\"><a href=\"#2-3-使用-FutureTask-方式\" class=\"headerlink\" title=\"2.3 使用 FutureTask 方式\"></a>2.3 使用 FutureTask 方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FutureTaskThreadDemo</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CallerTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Callable</span>&lt;String&gt; &#123;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;violet&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FutureTask</span>&lt;String&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CallerTask</span>()); <br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(futureTask).start();<br>        <br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">res</span> <span class=\"hljs-operator\">=</span> futureTask.get();<br>            System.out.println(<span class=\"hljs-string\">&quot;线程执行完成返回结果：&quot;</span> + res);<br>        &#125; <span class=\"hljs-keyword\">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-线程通知与等待\"><a href=\"#3-线程通知与等待\" class=\"headerlink\" title=\"3.线程通知与等待\"></a>3.线程通知与等待</h3><p>Java 中的 Object 类是所有类的父类，鉴于继承机制， Java 把所有类都需要的方法放到了 Object 类里面，其中就包含线程通知与等待系列函数。</p>\n<h4 id=\"3-1-wait-函数\"><a href=\"#3-1-wait-函数\" class=\"headerlink\" title=\"3.1 wait() 函数\"></a>3.1 wait() 函数</h4><p>当一个线程调用一个共享变量 wait() 方法时, 该调用线程会被阻塞挂起, 到发生下面几件事情之一才返回:</p>\n<ul>\n<li>其他线程调用了该共享对象 notify() 或者 notifyAll() 方法</li>\n<li>其他线程调用了该线程 interrupt() 方法, 该线程抛出 InterruptedException 异常返回。</li>\n</ul>\n<blockquote>\n<p>如果调用 wait()方法的线程没有事先获取该对象的监视器锁，则调用 wait() 方法时调用 线程会抛出 IllegalMonitorStateExce ption 异常。</p>\n</blockquote>\n<h4 id=\"3-2-notify-函数\"><a href=\"#3-2-notify-函数\" class=\"headerlink\" title=\"3.2 notify() 函数\"></a>3.2 notify() 函数</h4><p>唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程。</p>\n<h4 id=\"3-3-notifyAll-函数\"><a href=\"#3-3-notifyAll-函数\" class=\"headerlink\" title=\"3.3 notifyAll() 函数\"></a>3.3 notifyAll() 函数</h4><p>唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</p>\n<h4 id=\"3-4等待线程执行终止的-join-方法\"><a href=\"#3-4等待线程执行终止的-join-方法\" class=\"headerlink\" title=\"3.4等待线程执行终止的 join 方法\"></a>3.4等待线程执行终止的 join 方法</h4><p>在项目实践中经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。</p>\n<h4 id=\"3-5-让线程睡眠的-sleep-方法\"><a href=\"#3-5-让线程睡眠的-sleep-方法\" class=\"headerlink\" title=\"3.5 让线程睡眠的 sleep 方法\"></a>3.5 让线程睡眠的 sleep 方法</h4><p>当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。</p>\n<h4 id=\"3-6-让出-CPU-执行权的-yield-方法\"><a href=\"#3-6-让出-CPU-执行权的-yield-方法\" class=\"headerlink\" title=\"3.6 让出 CPU 执行权的 yield 方法\"></a>3.6 让出 CPU 执行权的 yield 方法</h4><p>Thread 有一个静态的 yield 方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己 CPU 使用，但是线程调度器可以无条件忽略这个暗示。</p>\n<h4 id=\"3-7-线程中断\"><a href=\"#3-7-线程中断\" class=\"headerlink\" title=\"3.7 线程中断\"></a>3.7 线程中断</h4><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p>\n<ul>\n<li><strong>void interrupt()</strong>: 中断线程，例如，当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。设置标志仅仅是设置标志，线程 A 实际并没有被中断，它会继续往下执行。如果线程 A 因为调用了 wait 系列函数、join 方法或者 sleep 方法而被阻塞挂起，这时候若线程 B 调用线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。</li>\n<li><strong>boolean isInterrupted() 方法</strong>: 检测当前线程是否被中断，如果是返回 true, 否则返回 false。  </li>\n<li><strong>boolean interrupted() 方法</strong>: 检测当前线程是否被中断，如果是返回 true，否则返回 false。与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是 static 方法，可以通过 Thread 类直接调用。另外从下面给的代码可以知道，在 interrupted() 内部是获取当前调用线程的中断标志而不是调用 interrupted() 方法的实例对象的中断标志。</li>\n</ul>\n<h4 id=\"3-8-理解线程上下文切换\"><a href=\"#3-8-理解线程上下文切换\" class=\"headerlink\" title=\"3.8 理解线程上下文切换\"></a>3.8 理解线程上下文切换</h4><p>当前线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占有，这就是上下文切换。</p>\n<blockquote>\n<p>线程上下文切换时机有：当前线程的 CPU 时间片使用完处于就绪状态时，当前线程被其他线程中断时。</p>\n</blockquote>\n<h4 id=\"3-9-线程死锁\"><a href=\"#3-9-线程死锁\" class=\"headerlink\" title=\"3.9 线程死锁\"></a>3.9 线程死锁</h4><h5 id=\"3-9-1-什么是线程死锁\"><a href=\"#3-9-1-什么是线程死锁\" class=\"headerlink\" title=\"3.9.1 什么是线程死锁\"></a>3.9.1 什么是线程死锁</h5><p>死锁是指两个或两个以上的线程在执行任务过程中，因争夺资源而造成的互相等待的现象。</p>\n<h5 id=\"3-9-2-死锁产生的必要条件\"><a href=\"#3-9-2-死锁产生的必要条件\" class=\"headerlink\" title=\"3.9.2 死锁产生的必要条件\"></a>3.9.2 死锁产生的必要条件</h5><ul>\n<li><p>互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</p>\n</li>\n<li><p>请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所有当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</p>\n</li>\n<li><p>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</p>\n</li>\n<li><p>环路等待条件：指在发生死锁时，必然存在一个线程–资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源，T1 正在等待 T2 占用的资源，······Tn 正在等待已被 T0 占用的资源。</p>\n</li>\n</ul>\n<h5 id=\"3-9-3-如何避免线程死锁\"><a href=\"#3-9-3-如何避免线程死锁\" class=\"headerlink\" title=\"3.9.3 如何避免线程死锁\"></a>3.9.3 如何避免线程死锁</h5><p>要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但是学过操作系统的读者应该都知道，目前只有请求并持有和环路等待条件是可以被破坏的。</p>\n<h4 id=\"3-10-守护线程与用户线程\"><a href=\"#3-10-守护线程与用户线程\" class=\"headerlink\" title=\"3.10 守护线程与用户线程\"></a>3.10 守护线程与用户线程</h4><p>守护线程是为用户线程服务的，当一个程序中的所有用户线程都执行完成之后程序就会结束运行，程序结束运行时不会管守护线程是否正在运行。</p>\n<blockquote>\n<p>即使是守护线程，当程序中调用 join() 方法时，程序依然会等待守护线程执行完成之后再结束进程。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>《Java并发编程之美》</li>\n</ul>\n"},{"title":"学习过程中陌生的单词","date":"2023-02-14T03:57:25.000Z","description":"学习过程中陌生的单词。","_content":"\n* decoy：n.诱饵 v.引诱\n* differ：vi.不同\n* counterpart：n.对应方; 职位(或作用)相当的人\n* independent: adj.独立的\n* typical：adj.典型的\n* assign: vt.分派；委派\n* invoke：vt.提出；调用\n* subsequent: adj.后来的; 随后的;\n* implicit: adj.含蓄的，无疑问的\n* as long as：只要；和...一样长\n* access：n.通道；vt.访问，到达\n* subject：n.主题；vt.使...臣服；adj.可能受...的影响\n* garbage：n.(生活)垃圾；垃圾桶\n* probe：v.探查；追问；n.探究\n* linear：adj.线性的，直线的\n* inheritable: adj.可遗传的\n* custom：n.风俗，习性；adj.定做的\n* collision：n.碰撞；（两人之间或对立意见、看法等之间的）冲突\n* eliminate：vt.消除，排除\n* consecutive：adj.连续的\n* behave：v.表现，举止\n* sequential：adj.连续的，按次序的；\n* optimal：adj.最优的，最佳的\n* multiplicative：n.乘法；adj.增加的；倍增的\n* in which：在其中；在...其中；\n* anonymous：adj.匿名的\n* threshold：n.门槛，阈，界\n* expunge：vt.消除，消去\n* stale: adj.陈腐的；不新鲜的；n.(牛马、骆驼)尿；vt.使陈旧\n* solely：adv.唯一地；仅；只；\n* concurrent: adj.同时发生的; n.共存物\n* priority：n.优先；优先权\n* allocate: vt.分配\n* prime: adj.首要的；n.盛年；\n* purpose：n.意图；目的；vt.有意；打算\n* pertain：vi.适合\n* indicate：v.表明；暗示\n* hint: n.暗示；征兆；v.暗示\n* yield：n.产量；利润；v.屈服；提供\n* heuristic：adj.(教学或教育)启发式的\n* improve：v.改善；改进\n* relative：adj.相对的；比较的；n.亲戚；亲属；同类事物\n* otherwise：否则\n* utilise：vt.利用；使用\n* combine：v.结合；联合；n.集团\n* profile: n.简介；概述；vt.概述\n* benchmark: n.基准；vt.检测(用基准问题测试)\n* appropriate：适合的；恰当的；vt.盗用；挪用；占用\n* reproduce：v.复制；繁殖；\n* specify：vt.具体说明；详述\n* precision：n.精确；细致；adj.精确的；\n* accuracy：n.精确(程度)；准确(性)\n* ownership：n.所有权\n* negative：adj.消极的；负面的；n.否定；vt.否定；拒绝\n* supply：n.供给；供应；v.提供\n* persistent：adj.执着的；不屈不挠的\n* conceptual：adj.概念(上)的；\n* \n* ","source":"_posts/Java基础知识/多线程/学习过程中陌生的单词/学习过程中陌生的单词.md","raw":"---\ntitle: 学习过程中陌生的单词\ncategories: [\"单词学习\"]\ndate: 2023-02-14 11:57:25\ntags: 单词学习\ndescription: 学习过程中陌生的单词。\n---\n\n* decoy：n.诱饵 v.引诱\n* differ：vi.不同\n* counterpart：n.对应方; 职位(或作用)相当的人\n* independent: adj.独立的\n* typical：adj.典型的\n* assign: vt.分派；委派\n* invoke：vt.提出；调用\n* subsequent: adj.后来的; 随后的;\n* implicit: adj.含蓄的，无疑问的\n* as long as：只要；和...一样长\n* access：n.通道；vt.访问，到达\n* subject：n.主题；vt.使...臣服；adj.可能受...的影响\n* garbage：n.(生活)垃圾；垃圾桶\n* probe：v.探查；追问；n.探究\n* linear：adj.线性的，直线的\n* inheritable: adj.可遗传的\n* custom：n.风俗，习性；adj.定做的\n* collision：n.碰撞；（两人之间或对立意见、看法等之间的）冲突\n* eliminate：vt.消除，排除\n* consecutive：adj.连续的\n* behave：v.表现，举止\n* sequential：adj.连续的，按次序的；\n* optimal：adj.最优的，最佳的\n* multiplicative：n.乘法；adj.增加的；倍增的\n* in which：在其中；在...其中；\n* anonymous：adj.匿名的\n* threshold：n.门槛，阈，界\n* expunge：vt.消除，消去\n* stale: adj.陈腐的；不新鲜的；n.(牛马、骆驼)尿；vt.使陈旧\n* solely：adv.唯一地；仅；只；\n* concurrent: adj.同时发生的; n.共存物\n* priority：n.优先；优先权\n* allocate: vt.分配\n* prime: adj.首要的；n.盛年；\n* purpose：n.意图；目的；vt.有意；打算\n* pertain：vi.适合\n* indicate：v.表明；暗示\n* hint: n.暗示；征兆；v.暗示\n* yield：n.产量；利润；v.屈服；提供\n* heuristic：adj.(教学或教育)启发式的\n* improve：v.改善；改进\n* relative：adj.相对的；比较的；n.亲戚；亲属；同类事物\n* otherwise：否则\n* utilise：vt.利用；使用\n* combine：v.结合；联合；n.集团\n* profile: n.简介；概述；vt.概述\n* benchmark: n.基准；vt.检测(用基准问题测试)\n* appropriate：适合的；恰当的；vt.盗用；挪用；占用\n* reproduce：v.复制；繁殖；\n* specify：vt.具体说明；详述\n* precision：n.精确；细致；adj.精确的；\n* accuracy：n.精确(程度)；准确(性)\n* ownership：n.所有权\n* negative：adj.消极的；负面的；n.否定；vt.否定；拒绝\n* supply：n.供给；供应；v.提供\n* persistent：adj.执着的；不屈不挠的\n* conceptual：adj.概念(上)的；\n* \n* ","slug":"Java基础知识/多线程/学习过程中陌生的单词/学习过程中陌生的单词","published":1,"updated":"2023-02-16T08:14:23.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle6uilnk0005rgtv2f7heq62","content":"<ul>\n<li>decoy：n.诱饵 v.引诱</li>\n<li>differ：vi.不同</li>\n<li>counterpart：n.对应方; 职位(或作用)相当的人</li>\n<li>independent: adj.独立的</li>\n<li>typical：adj.典型的</li>\n<li>assign: vt.分派；委派</li>\n<li>invoke：vt.提出；调用</li>\n<li>subsequent: adj.后来的; 随后的;</li>\n<li>implicit: adj.含蓄的，无疑问的</li>\n<li>as long as：只要；和…一样长</li>\n<li>access：n.通道；vt.访问，到达</li>\n<li>subject：n.主题；vt.使…臣服；adj.可能受…的影响</li>\n<li>garbage：n.(生活)垃圾；垃圾桶</li>\n<li>probe：v.探查；追问；n.探究</li>\n<li>linear：adj.线性的，直线的</li>\n<li>inheritable: adj.可遗传的</li>\n<li>custom：n.风俗，习性；adj.定做的</li>\n<li>collision：n.碰撞；（两人之间或对立意见、看法等之间的）冲突</li>\n<li>eliminate：vt.消除，排除</li>\n<li>consecutive：adj.连续的</li>\n<li>behave：v.表现，举止</li>\n<li>sequential：adj.连续的，按次序的；</li>\n<li>optimal：adj.最优的，最佳的</li>\n<li>multiplicative：n.乘法；adj.增加的；倍增的</li>\n<li>in which：在其中；在…其中；</li>\n<li>anonymous：adj.匿名的</li>\n<li>threshold：n.门槛，阈，界</li>\n<li>expunge：vt.消除，消去</li>\n<li>stale: adj.陈腐的；不新鲜的；n.(牛马、骆驼)尿；vt.使陈旧</li>\n<li>solely：adv.唯一地；仅；只；</li>\n<li>concurrent: adj.同时发生的; n.共存物</li>\n<li>priority：n.优先；优先权</li>\n<li>allocate: vt.分配</li>\n<li>prime: adj.首要的；n.盛年；</li>\n<li>purpose：n.意图；目的；vt.有意；打算</li>\n<li>pertain：vi.适合</li>\n<li>indicate：v.表明；暗示</li>\n<li>hint: n.暗示；征兆；v.暗示</li>\n<li>yield：n.产量；利润；v.屈服；提供</li>\n<li>heuristic：adj.(教学或教育)启发式的</li>\n<li>improve：v.改善；改进</li>\n<li>relative：adj.相对的；比较的；n.亲戚；亲属；同类事物</li>\n<li>otherwise：否则</li>\n<li>utilise：vt.利用；使用</li>\n<li>combine：v.结合；联合；n.集团</li>\n<li>profile: n.简介；概述；vt.概述</li>\n<li>benchmark: n.基准；vt.检测(用基准问题测试)</li>\n<li>appropriate：适合的；恰当的；vt.盗用；挪用；占用</li>\n<li>reproduce：v.复制；繁殖；</li>\n<li>specify：vt.具体说明；详述</li>\n<li>precision：n.精确；细致；adj.精确的；</li>\n<li>accuracy：n.精确(程度)；准确(性)</li>\n<li>ownership：n.所有权</li>\n<li>negative：adj.消极的；负面的；n.否定；vt.否定；拒绝</li>\n<li>supply：n.供给；供应；v.提供</li>\n<li>persistent：adj.执着的；不屈不挠的</li>\n<li>conceptual：adj.概念(上)的；</li>\n<li></li>\n<li></li>\n</ul>\n","site":{"data":{}},"wordcount":1181,"excerpt":"","more":"<ul>\n<li>decoy：n.诱饵 v.引诱</li>\n<li>differ：vi.不同</li>\n<li>counterpart：n.对应方; 职位(或作用)相当的人</li>\n<li>independent: adj.独立的</li>\n<li>typical：adj.典型的</li>\n<li>assign: vt.分派；委派</li>\n<li>invoke：vt.提出；调用</li>\n<li>subsequent: adj.后来的; 随后的;</li>\n<li>implicit: adj.含蓄的，无疑问的</li>\n<li>as long as：只要；和…一样长</li>\n<li>access：n.通道；vt.访问，到达</li>\n<li>subject：n.主题；vt.使…臣服；adj.可能受…的影响</li>\n<li>garbage：n.(生活)垃圾；垃圾桶</li>\n<li>probe：v.探查；追问；n.探究</li>\n<li>linear：adj.线性的，直线的</li>\n<li>inheritable: adj.可遗传的</li>\n<li>custom：n.风俗，习性；adj.定做的</li>\n<li>collision：n.碰撞；（两人之间或对立意见、看法等之间的）冲突</li>\n<li>eliminate：vt.消除，排除</li>\n<li>consecutive：adj.连续的</li>\n<li>behave：v.表现，举止</li>\n<li>sequential：adj.连续的，按次序的；</li>\n<li>optimal：adj.最优的，最佳的</li>\n<li>multiplicative：n.乘法；adj.增加的；倍增的</li>\n<li>in which：在其中；在…其中；</li>\n<li>anonymous：adj.匿名的</li>\n<li>threshold：n.门槛，阈，界</li>\n<li>expunge：vt.消除，消去</li>\n<li>stale: adj.陈腐的；不新鲜的；n.(牛马、骆驼)尿；vt.使陈旧</li>\n<li>solely：adv.唯一地；仅；只；</li>\n<li>concurrent: adj.同时发生的; n.共存物</li>\n<li>priority：n.优先；优先权</li>\n<li>allocate: vt.分配</li>\n<li>prime: adj.首要的；n.盛年；</li>\n<li>purpose：n.意图；目的；vt.有意；打算</li>\n<li>pertain：vi.适合</li>\n<li>indicate：v.表明；暗示</li>\n<li>hint: n.暗示；征兆；v.暗示</li>\n<li>yield：n.产量；利润；v.屈服；提供</li>\n<li>heuristic：adj.(教学或教育)启发式的</li>\n<li>improve：v.改善；改进</li>\n<li>relative：adj.相对的；比较的；n.亲戚；亲属；同类事物</li>\n<li>otherwise：否则</li>\n<li>utilise：vt.利用；使用</li>\n<li>combine：v.结合；联合；n.集团</li>\n<li>profile: n.简介；概述；vt.概述</li>\n<li>benchmark: n.基准；vt.检测(用基准问题测试)</li>\n<li>appropriate：适合的；恰当的；vt.盗用；挪用；占用</li>\n<li>reproduce：v.复制；繁殖；</li>\n<li>specify：vt.具体说明；详述</li>\n<li>precision：n.精确；细致；adj.精确的；</li>\n<li>accuracy：n.精确(程度)；准确(性)</li>\n<li>ownership：n.所有权</li>\n<li>negative：adj.消极的；负面的；n.否定；vt.否定；拒绝</li>\n<li>supply：n.供给；供应；v.提供</li>\n<li>persistent：adj.执着的；不屈不挠的</li>\n<li>conceptual：adj.概念(上)的；</li>\n<li></li>\n<li></li>\n</ul>\n"},{"title":"行为型模式-策略模式","date":"2023-02-14T03:01:16.000Z","description":"关于设计模式中的策略模式的探索。","_content":"## 一、 定义\n策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n\n## ","source":"_posts/理论知识/设计模式/行为型模式/设计模式.md","raw":"---\ntitle: 行为型模式-策略模式\ncategories: [\"理论知识\", \"设计模式\", \"行为型模式\"]\ndate: 2023-02-14 11:01:16\ntags: 设计模式\ndescription: 关于设计模式中的策略模式的探索。\n---\n## 一、 定义\n策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n\n## ","slug":"理论知识/设计模式/行为型模式/设计模式","published":1,"updated":"2023-02-16T08:04:04.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle6uilnr0006rgtv48rm761o","content":"<h2 id=\"一、-定义\"><a href=\"#一、-定义\" class=\"headerlink\" title=\"一、 定义\"></a>一、 定义</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"wordcount":54,"excerpt":"","more":"<h2 id=\"一、-定义\"><a href=\"#一、-定义\" class=\"headerlink\" title=\"一、 定义\"></a>一、 定义</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"},{"title":"设计原则","date":"2023-02-14T04:07:57.000Z","description":null,"_content":"* 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n>把会变化的部分取出并 \"封装\" 起来，好让其他部分不会受到影响。\n\n* 针对接口编程，而不是针对实现编程。\n> 类的行为将被放在分开的类中，此类专门提供某行为接口的实现，这样就不需要知道类具体的实现细节。\n\n* 多用组合，少用继承。\n>使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以 \"在运行时动态的改变行为\"，只要组合的行为对象符合正确的接口标准即可。","source":"_posts/理论知识/设计模式/设计原则/设计原则.md","raw":"---\ntitle: 设计原则\ncategories: [\"理论知识\", \"设计模式\", \"设计原则\"]\ndate: 2023-02-14 12:07:57\ntags: 设计原则\ndescription: \n---\n* 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n>把会变化的部分取出并 \"封装\" 起来，好让其他部分不会受到影响。\n\n* 针对接口编程，而不是针对实现编程。\n> 类的行为将被放在分开的类中，此类专门提供某行为接口的实现，这样就不需要知道类具体的实现细节。\n\n* 多用组合，少用继承。\n>使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以 \"在运行时动态的改变行为\"，只要组合的行为对象符合正确的接口标准即可。","slug":"理论知识/设计模式/设计原则/设计原则","published":1,"updated":"2023-02-16T08:04:18.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cle6uilns0007rgtv9kmcegh3","content":"<ul>\n<li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>\n<blockquote>\n<p>把会变化的部分取出并 “封装” 起来，好让其他部分不会受到影响。</p>\n</blockquote>\n</li>\n<li><p>针对接口编程，而不是针对实现编程。</p>\n<blockquote>\n<p>类的行为将被放在分开的类中，此类专门提供某行为接口的实现，这样就不需要知道类具体的实现细节。</p>\n</blockquote>\n</li>\n<li><p>多用组合，少用继承。</p>\n<blockquote>\n<p>使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以 “在运行时动态的改变行为”，只要组合的行为对象符合正确的接口标准即可。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":210,"excerpt":"","more":"<ul>\n<li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>\n<blockquote>\n<p>把会变化的部分取出并 “封装” 起来，好让其他部分不会受到影响。</p>\n</blockquote>\n</li>\n<li><p>针对接口编程，而不是针对实现编程。</p>\n<blockquote>\n<p>类的行为将被放在分开的类中，此类专门提供某行为接口的实现，这样就不需要知道类具体的实现细节。</p>\n</blockquote>\n</li>\n<li><p>多用组合，少用继承。</p>\n<blockquote>\n<p>使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以 “在运行时动态的改变行为”，只要组合的行为对象符合正确的接口标准即可。</p>\n</blockquote>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cle6uilnk0005rgtv2f7heq62","category_id":"cle6uilnv000crgtv3ob143se","_id":"cle6uilnw000hrgtvelrpfcx3"},{"post_id":"cle6uilnb0001rgtv114k32d6","category_id":"cle6uilnh0003rgtv2qpm55ol","_id":"cle6uilnz000lrgtv2tf817mb"},{"post_id":"cle6uilnb0001rgtv114k32d6","category_id":"cle6uilnw000frgtvfsw46sjl","_id":"cle6uilnz000mrgtv54bq3khv"},{"post_id":"cle6uilne0002rgtvh5ssb5k1","category_id":"cle6uilnt0008rgtvcpfm0ub3","_id":"cle6uilo0000orgtvg1fs6uoi"},{"post_id":"cle6uilne0002rgtvh5ssb5k1","category_id":"cle6uilny000krgtv8kd7b90q","_id":"cle6uilo0000qrgtve7b72zz0"},{"post_id":"cle6uilnr0006rgtv48rm761o","category_id":"cle6uilnh0003rgtv2qpm55ol","_id":"cle6uilo1000rrgtv24gwfe40"},{"post_id":"cle6uilnr0006rgtv48rm761o","category_id":"cle6uilnw000frgtvfsw46sjl","_id":"cle6uilo1000srgtv9yp8fxpz"},{"post_id":"cle6uilnr0006rgtv48rm761o","category_id":"cle6uilnz000nrgtvc7yc6raq","_id":"cle6uilo1000trgtv4ji82mrz"},{"post_id":"cle6uilns0007rgtv9kmcegh3","category_id":"cle6uilnh0003rgtv2qpm55ol","_id":"cle6uilo1000urgtv6ogn18be"},{"post_id":"cle6uilns0007rgtv9kmcegh3","category_id":"cle6uilnw000frgtvfsw46sjl","_id":"cle6uilo1000vrgtvdv0e6qe6"},{"post_id":"cle6uilns0007rgtv9kmcegh3","category_id":"cle6uilo0000prgtv1mzqa9em","_id":"cle6uilo2000wrgtvak3j6iyi"}],"PostTag":[{"post_id":"cle6uilnr0006rgtv48rm761o","tag_id":"cle6uilnj0004rgtvciqvh2a1","_id":"cle6uilnu000argtv4zuv7l1f"},{"post_id":"cle6uilnb0001rgtv114k32d6","tag_id":"cle6uilnj0004rgtvciqvh2a1","_id":"cle6uilnv000brgtvgx0f7xyz"},{"post_id":"cle6uilnk0005rgtv2f7heq62","tag_id":"cle6uilnt0009rgtv532k30jp","_id":"cle6uilnv000ergtv6phgdh2z"},{"post_id":"cle6uilns0007rgtv9kmcegh3","tag_id":"cle6uilnv000drgtv3tqqc4zr","_id":"cle6uilnw000grgtvevhe5pdf"}],"Tag":[{"name":"设计模式","_id":"cle6uilnj0004rgtvciqvh2a1"},{"name":"单词学习","_id":"cle6uilnt0009rgtv532k30jp"},{"name":"设计原则","_id":"cle6uilnv000drgtv3tqqc4zr"}]}}