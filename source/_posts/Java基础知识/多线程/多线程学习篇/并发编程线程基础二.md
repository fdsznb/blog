---
title: 并发编程线程基础二
categories: ["Java基础知识", "多线程学习"]
date: 2023-02-17 14:18:17
tags: 
description:
---
### 1.什么是多线程并发编程
* 并发：并发是指一个时间段内多个任务同时在执行，并且都没有执行结束。
* 并行：并行是指单位时间内多个任务同时在执行。
>并发任务强调在一个时间段内同时执行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行。

### 2.为什么要进行多线程并发编程
多核 CPU 时代的到来打破了单核 CPU 对多线程效能的限制。多个 CPU 意味着每个线程可以使用自己的 CPU 运行，这减少了线程上下文的开销，但随着对应用系统性能和吞吐量要求的提高，出现了处理海量数据和请求的要求，这些都对高并发编程有着迫切的需求。

### 3.Java 中的线程安全问题
线程安全问题是指当多个线程同时读写一个共享资源并且没有任何同步措施时，导致出现脏数据或者其他不可预见的结果的问题。

### 4.Java 中共享变量的内存可见性问题
Java 内存规模规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫工作内存，线程读写变量时操作的是自己工作内存的变量。

> 多线程情况下会出现内存不可见问题

### 5. Java 中的 synchronized 关键字
#### 5.1 synchronized 关键字介绍
synchronized 块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。
>线程的执行代码进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的 wait 系列方法时释放该内置锁(排他锁)。

>另外，由于 Java 中的线程与操作系统的原生线程一一对应，所以当阻塞一个线城时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，而 synchronized 的使用就会导致上下文切换。

#### 5.2 synchronized 的内存语义
进入 synchronized 块的语义是把在 synchronized 块内使用到的变量从线程的工作内存中清除，这样在 synchronized 块内使用该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出 synchronized 块的内存语义是把在 synchronized 块内对内存共享变量的修改刷新到主内存。
>这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从内存进行加载，在释放时将本地内存中修改的共享变量刷新到主内存。

>除可以解决共享变量内存可见性问题外，synchronized 经常被用来实现原子性操作。另外请注意，synchronized 关键字会引起线程上下文切换带来的线程调度开销。

### 6.Java 中的 volatile 关键字
volatile关键字可以确保对一个变量的更新对其他线程马上可见，当一个变量被声明为 volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。
>volatile 的内存语义和 synchronized 有相似之处，集体来说就是：当线程写入了 volatile 变量值时就等价于线程退出 synchronized 同步块 (把写入工作内存的变量值同步到主内存)，读取 volatile 变量值时就相当于进入同步块 (先清空本地内存变量值，再从主内存获取最新值)。

>volatile 虽然提供了可见性保证，但并不保证操作的原子性。

什么时候才使用 volatile 关键字：
* 写入变量不依赖变量的当前值时。
>因为如果依赖当前值，将是获取--计算--写入三步操作，这三步操作不是原子性的，而 volitile 不保证原子性。
* 读写变量值时没有加锁。
>因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为 volitile 的。

### 7.Java 中的原子性操作
所谓原子性操作，是指执行一系列操作时，这些操作要么全部执行，要么全部不执行，不存在只执行其中一部分的情况。

### 8.Java 中的 CAS 操作
CAS 即 Compare and Swap，其实是 JDK 提供的非阻塞原子性操作，它通过硬件保证了比较--更新操作的原子性。JDK 里面的 Unsafe 类提供了一系列的 compareAndSwap* 方法，我们以 compareAndSwapLong 方法进行简单介绍。
* boolean compareAndSwapLong(Object obj, long valueOffeset, long expect, long update) 方法：其中四个参数分别是内存位置、对象中的变量的偏移量、变量预期值和新的值。其操作含义是，如果对象 obj 中内存偏移量为 valueOffset 的变量值为 expect，则使用新的值 update 替换旧的值 expect。

### 9.Unsafe 类
#### 9.1 Unsafe 类中的重要方法
JDK 的 rt.jar 包中的 Unsafe 类提供了硬件级别的原子性操作，Unsafe 类中的方法都是 native 方法，它们使用 JNI 的方式访问本地 C++ 实现库。